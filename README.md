# KClass

Disclaimer: After working on this for a while I've come to the conclusion that there is an inherent flaw in the design of this system that I don't think can be solved. The case where an inherited method attempts to call a private method from the base class will end up failing because the private method is not inherited. I haven't come up with a solution for this problem, but I am aware of it's existence.

Additionally, JavaScript supports better mechanisms to defining classes such as closures and the class syntax brought in by the ES6 standard. I'd suggest you use those depending on your needs. Closures can provide private variables and methods if you need them.

KClass (or better name if you can suggest one) is a small set of functions to help simplify JavaScript programming. The goals for the project are:
1. Simulating Classical-Inheritance.
2. Provide private properties and methods
3. Utilize Prototype chain effectively.
4. Disrupt the "expected" form when writing as little as possible.

KClass provides a simple, easy to read and understand format for defining class. This can include private methods if desired. Each private and public method exists on the class prototype. This means you have one instance of that method per class.
```
var Point = KClass.defClass({
  className: 'Point',
  debug: false,
  ctor: function(x, y) {
    this.x = x || 0;
    this.y = y || 0;
  },
  public: {
    getX: function() {
      return this.x;
    },
    getY: function() {
      return this.y;
    },
    toString: function() {
      return this.getFormatted();
    }
  },
  private: {
    getFormatted: function() {
      return 'Point[' + this.x + ', '+ this.y + ']';
    }
  }
});
```
The keywords used here are as follows:
  ctor: Optional. Function to be used as the constructor for the class. If not provided a do-nothing constructor will be added in.
  debug: Optional. Adds in a myId to objects to label them. Useful for debugging but should be turned off otherwise. Defaults to false.
  className: Optional. Name for the class. The constructor function returned from defClass will be named this. Defaults to 'anonymous'.
  public: Optional. An object that contains public functions/methods for the class. Defaults to {}.
  private: Optional. An object that contains private functions/methods for the class. Defaults to {}.
  static: Optional. An object that contains static functions/methods for the class. These methods will not be available on instances of the class. They will be on the constructor return from defClass.
  superclass: Optional. A constructor function that will be used as the superclass. Does not need to be a class generated by KClass.

When an object is created, two (or more instances) are created. The one you get a handle back to is called the "public instance".
```
var p1 = new Point(13, 37);
```
The public instance will appear to be a blank-slate. It has no own properties at all. It will have inherited propties from its prototype, getX, getY, and toString. 
Hidden inside is another object called the "private instance". The private instance for p1 contains all the properties set on it. It would have properties x = 13 and y = 37. It also inherits from the private prototype, which in turn inherits from the public prototype, so it will have getX, getY, and toString functions from the public prototype, and getFormatted from the private prototype.
Each time you call a method on a KClass, the context "this" gets set to the private instance. This makes it so you can effectively call any public or private methods from within the class definition.
The other functions bundled with KClass are is, wrap, and unwrap. They all serve to assist in writing classes with KClass.
is: function(obj1, obj2) - Returns true if the two objects refer to the same public instance. This is useful if you are working with a class that inherits from another class. Each class gets its own private instance so it is possible to have 2 private instances for the same class that are not the same object, but are both for the same public instance. For most cases they are the same object, and this function helps determine that.
wrap: function(obj) - Return the public instance for the given object. If the given object does not have an associated public instance, an error is thrown (Subject to change. I have not tested the usability on this very much)
unwrap: function(obj, class) - Return the private instance for the given object and class combination. If the given object and class combination cannot find a private instance, then an error is thrown (Subject to change. I have not tested the usability of this very much)
